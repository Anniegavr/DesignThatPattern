# Design Patterns
### Laboratory Work on Design Patterns
#### Lab #1: Creational DP - Anastasia Gavrilita

_**Check the older repo - currently named "demo" to see earlier commits. The repo was switched due to some technical issues.**_

#### **Intro**

Design patterns are typical solutions to commonly occurring problems in software design. They are like pre-made blueprints that you can customize to solve a recurring design problem in the code.
The most common classification of patterns in programming is: creational, structural and behavioral patterns. Creational patterns provide various object creation mechanisms, which increase flexibility and reuse of existing code.

#### **Implementation**

The code above presents an example of an abstract factory (IRecommFactory) that is implemented by factories which contain factory methods (BodyActivityRecommFactory & WatchRecommFactory)- all stored in the Factories package (Img. 1 & 2)

![image](https://user-images.githubusercontent.com/56108881/136357994-f8ba6765-d19d-4c9a-83c2-af976bb10bca.png)
#### Image 1: Factory method for the abstract factory, for choosing between sports and watch recommendations (based on enums)

![image](https://user-images.githubusercontent.com/56108881/136356884-b67cbc63-c0b8-414e-a92d-60db7a01b028.png)
#### Image 2: Factory method for the abstract factory, for choosing between type of sports and between types of watch recommendations (based on enums)

What's more, the client and his saved preferences are instantiated as singletons - see the Client and the Models packages. A switch is used for each of the concrete factories' implementation (Img. 3).
![image](https://user-images.githubusercontent.com/56108881/136357390-47fe3ae5-c417-4535-ac97-675ad40deeb2.png)
#### Image 3: Clients and their saved recommendations as singleton objects with a thread-safe method

The project mocks up an app that suggests activities based on 2 main criteria: the type of activity (sporty or not & the intensity o concentratrion required). Sport-related recommendations - for hiking, running & walking w/h a friend - will also contain filters for places; watching recommendations will be filtered based on genres. More filters might be added later on. The datasets for watching recommendations are archived and stored inside the Models package.

Check the UML diagram below for a better perspective on the project's structure (Img. 4).

![image](https://user-images.githubusercontent.com/56108881/135888762-a2457dc8-5a55-4379-b9b5-4f25a9769d60.png)
#### Image 4: UML diagram of all the classes, generated by IntelliJ plugin

Although the used patterns are quite common and trivial, it's what was needed for the specific task they do. It's important to understand which pattern is necessarry for a specific task.

#### Lab #2: Structural DP - Anastasia Gavrilita
#### **Intro**
According to Refactoring.Guru, "Structural patterns explain how to assemble objects and classes into larger structures while keeping these structures flexible and efficient". Some of the most known structural DP are: adapter, bridge, composite, decorator, proxy, facade and flyweight.

#### **Implementation**
The code above mainly applies the following structural DP: adapter, decorator and facade.

#### Adapter
The adapter was created to enable database entities to read CSV datasets as database entities. Namely, I used datasets for the Anime and the TVSeries classes. The adapter package holds an abstract class called CSVHandler, that is extended by a concrete AnimeCSVHandler and TVSeriesCSVHandler. 

public abstract class CSVHandler {
    public static String TYPE = "text/csv";

    public static boolean hasCSVFormat(MultipartFile file){
        return TYPE.equals(file.getContentType());
    }

    public abstract List<?> parseCSV(InputStream is); //method being implemented
    
}

The process of reading into CSV files is aided by the CSVService class, located within the security.services package. The trickiest step is to extract only the necessarry fields of the datasets into the concrete classess of the recommendation factories: Anime and TVSeries, because the datasets have more fields than the Anime and the TVSeries classes have.
For example:
public class Anime{
  Long animeId;
  String name;
  String genres;
}
public class AnimeDataset{
private Long animeId;
    private String name;
    private String genre;
    private String type;
    private int episodes;
    private int rating;
    private int members;
}

To solve this, I created  additional services: AnimeService and TVSeriesService classes, that extract and insert the necessary information into the Anime and the TVSeries instances.

List<Anime> matchAnimes = new ArrayList<>();
for(AnimeDataset ad : matches){
    matchAnimes.add(new Anime(ad.getAnimeId(), ad.getName(), ad.getGenre()));
}

More examples of adapting the needs can be seen throughout services and controllers.

#### Decorator
The decorator patterns enables us to attach new functionalities to a class. In this sense, I made the original recommendations that only returned strings with advice return an additional information about users who have been given similar advice. This functionality shall help users connect with each other and form small communities based on their shared interests.

domain.factories.concrete_implementation.recommendation_decorator:

public class RecommendationWithBuddy {
    private final RecommendationsRepository recommendationsRepository;
    private final Recommendation recommendation;
    private String userWithSameInterests;

    public List<String> findInterestsBuddy(){
        List<Recommendation> getSimilars = new ArrayList<Recommendation>(recommendationsRepository.findRecommendationByRecommendationContaining(recommendation.getRecommendation()));
        List<String> getBuddyUsernames = new ArrayList<String>();
        for(Recommendation rec : getSimilars){
            getBuddyUsernames.add(rec.getClientUsername());
        }
        return getBuddyUsernames;
    }
}

#### Facade
A facade provides a simplified interface to a library, a framework, or any other complex set of classes. In this project, I used a well-defined facade within the facade package:
  
public class ClientDialog {
    private final ClientDetailsServiceImpl clientDetailsService;
    private final ClientService clientService;
    private final RecommendationsRepository recommendationsRepository;

    public void recommend(){
        IRecommFactory iRecommFactory;
        List<?> recommendationAnswer = null;
        Scanner sc = new Scanner(System.in);
        System.out.println("Choose a type of activity:" +
                "\n1.Activity involving the body\n2.Watch something");
        String requestRecommendation = sc.nextLine();
        System.out.println("Ok, now choose an option from the ones below:\n");
        System.out.println("1.An activity where I can multitask\n2.Shorter activity\n3.Longer activity");
        String choice = sc.nextLine();
        if(Objects.equals(requestRecommendation, "1")){
            iRecommFactory = new BodyActivityRecommFactory().createRecommendationType(choice);
            recommendationAnswer = iRecommFactory.returnRecommendation();
            System.out.println(recommendationAnswer);
        }
        else if(Objects.equals(requestRecommendation, "2")){
            iRecommFactory = new WatchRecommFactory().findRecommendation(choice);
            recommendationAnswer = iRecommFactory.returnRecommendation();
            System.out.println(recommendationAnswer);
        }
        else{
            System.out.println("You must choose and type the number of your choice, then hit ENTER");
            recommend();
        }
        System.out.println("Would you like to keep this recommendation in your history?\nyes/no:");
        String ans = sc.nextLine();
        if(Objects.equals(ans, "yes")){
            Long clientId = clientDetailsService.getUserIdFromToken();
            Optional<Client> findClient = clientService.getUsersById(clientId);
            if(findClient.isPresent()){
                String clientUsername = findClient.get().getUsername();
                Recommendation savingRecommendation = new Recommendation(clientId, clientUsername, recommendationAnswer);
                recommendationsRepository.save(savingRecommendation);
            }
        } else {
            System.out.println("Recommendation discarded\n");
        }
    }
}

The purpose of this facade is to outline and guide one through the steps of using the console app. Smaller facades are presented in services and controllers of this app.

#### Conclusion
Structural design patterns make it easier for one to explain the project classes, to come back to older projects or to share code projects with minimal need to go specifically through every single class. Structural design patterns allow a certain degree of abstraction and decoupling, which makes it easier for new functionalities to be added with little impact.

#### Lab #3: Behavioral DP - Anastasia Gavrilita
According to Refactoring.Guru, "Behavioral design patterns are concerned with algorithms and the assignment of responsibilities between objects". This laboratory work implements the State pattern, which enables a specific object alter its behavior as it's internal state changes.

The theme of the lab is the Hangman game (check the domain.statePattern package). The game instantiates a new Player object. Once the game starts, the player enters the GameOn state. As the player types characters in order to guess the word, the program checks whether the input matches the word to be guessed' characters. If the input character is correct, the player is still in the GameOn state. Else, the player enters the DownState, which checks whether the player still has lives left or not. If the player has 0 lives left, he enters the LostState which takes care of ending the game. Else, the player goes back to the GameOn state, now with the hangman drawing progressing on the screen. If the player guesses all of the searched word's characters, it enters the WinState, which also takes care of ending the game.
